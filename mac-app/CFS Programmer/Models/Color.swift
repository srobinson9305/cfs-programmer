//
//  Color.swift
//  CFS-Programmer
//
//  Created on 2025-12-24
//

import Foundation
import SwiftUI

// MARK: - Material Color Model

struct MaterialColor: Codable, Identifiable, Hashable {
    var id: UUID = UUID()
    var hex: String                     // "#FFFFFF"
    var name: String                    // "Transparent"
    var isPrimary: Bool = false         // For sync to CP6/Printer
    var autoGeneratedName: Bool = true  // Track if name was auto-generated
    
    // MARK: - Computed Properties
    
    /// Get SwiftUI Color from hex
    var color: Color {
        return Color(hex: hex) ?? .gray
    }
    
    /// Get display string for UI
    var displayName: String {
        return name.isEmpty ? hex : name
    }
    
    /// Check if this is a transparent/clear color
    var isTransparent: Bool {
        return name.lowercased().contains("transparent") ||
               name.lowercased().contains("clear")
    }
    
    // MARK: - Hashable
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    static func == (lhs: MaterialColor, rhs: MaterialColor) -> Bool {
        return lhs.id == rhs.id
    }
}

// MARK: - Color Extensions

extension Color {
    /// Initialize Color from hex string
    init?(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        
        Scanner(string: hex).scanHexInt64(&int)
        
        let r, g, b, a: UInt64
        switch hex.count {
        case 6: // RGB (no alpha)
            (r, g, b, a) = ((int >> 16) & 0xFF, (int >> 8) & 0xFF, int & 0xFF, 255)
        case 8: // RGBA
            (r, g, b, a) = ((int >> 24) & 0xFF, (int >> 16) & 0xFF, (int >> 8) & 0xFF, int & 0xFF)
        default:
            return nil
        }
        
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
    
    /// Convert Color to hex string
    func toHex() -> String? {
        guard let components = cgColor?.components, components.count >= 3 else {
            return nil
        }
        
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        return String(format: "#%02X%02X%02X",
                     Int(r * 255),
                     Int(g * 255),
                     Int(b * 255))
    }
}

// MARK: - Color Type Enum

enum ColorType: String, Codable, CaseIterable {
    case single = "single"
    case dual = "dual"
    case gradient = "gradient"
    
    var displayName: String {
        switch self {
        case .single: return "Single Color"
        case .dual: return "Dual Color"
        case .gradient: return "Gradient"
        }
    }
    
    var icon: String {
        switch self {
        case .single: return "paintbrush.fill"
        case .dual: return "paintbrush.pointed.fill"
        case .gradient: return "circle.lefthalf.filled"
        }
    }
}

// MARK: - Color Utilities

struct ColorUtilities {
    
    // MARK: - Comprehensive Color Name Database
    private static let colorNames: [String: String] = [
        // Basic Colors
        "#000000": "Black",
        "#FFFFFF": "White",
        "#FF0000": "Red",
        "#00FF00": "Green",
        "#0000FF": "Blue",
        "#FFFF00": "Yellow",
        "#FF00FF": "Magenta",
        "#00FFFF": "Cyan",
        
        // Common Colors
        "#FFA500": "Orange",
        "#800080": "Purple",
        "#808080": "Gray",
        "#A52A2A": "Brown",
        "#FFC0CB": "Pink",
        "#E6E6FA": "Lavender",
        "#008080": "Teal",
        "#F0E68C": "Khaki",
        "#FA8072": "Salmon",
        "#20B2AA": "Light Sea Green",
        "#87CEEB": "Sky Blue",
        "#FF6347": "Tomato",
        "#40E0D0": "Turquoise",
        "#EE82EE": "Violet",
        "#F5DEB3": "Wheat",
        
        // Dark Shades
        "#1A1A1A": "Dark Gray",
        "#333333": "Charcoal",
        "#8B0000": "Dark Red",
        "#006400": "Dark Green",
        "#00008B": "Dark Blue",
        "#8B008B": "Dark Magenta",
        "#556B2F": "Dark Olive Green",
        "#FF8C00": "Dark Orange",
        "#9932CC": "Dark Orchid",
        "#8B4513": "Saddle Brown",
        "#2F4F4F": "Dark Slate Gray",
        "#00CED1": "Dark Turquoise",
        
        // Light Shades
        "#F0F0F0": "Light Gray",
        "#FFB6C1": "Light Pink",
        "#ADD8E6": "Light Blue",
        "#90EE90": "Light Green",
        "#FFFFE0": "Light Yellow",
        "#FFE4E1": "Misty Rose",
        "#F0FFF0": "Honeydew",
        "#F0FFFF": "Azure",
        "#FFFAF0": "Floral White",
        
        // Metallic/Special
        "#D4AF37": "Metallic Gold",
        "#C0C0C0": "Silver",
        "#B87333": "Copper",
        "#E5E4E2": "Platinum",
        "#CD7F32": "Bronze",
        
        // Silk/Special Finishes (common in 3D printing)
        "#CC99FF": "Silk Purple",
        "#FF69B4": "Hot Pink",
        "#DC143C": "Crimson",
        "#32CD32": "Lime Green",
        "#FF1493": "Deep Pink",
        "#00BFFF": "Deep Sky Blue",
        "#4169E1": "Royal Blue",
        "#FFD700": "Silk Gold"
    ]
    
    /// Generate color name from hex value
    static func generateColorName(from hex: String) -> String {
        let normalizedHex = normalizeHex(hex)
        
        // Try exact match
        if let name = colorNames[normalizedHex] {
            return name
        }
        
        // Find closest color
        if let closest = findClosestColor(to: normalizedHex) {
            // If very close (distance < 30), use the name
            if let distance = getColorDistance(hex1: normalizedHex, hex2: closest.hex),
               distance < 30 {
                return closest.name
            }
            return "\(closest.name) Tint"
        }
        
        // If all else fails, generate descriptive name
        return generateDescriptiveName(from: normalizedHex)
    }
    
    /// Normalize hex string
    private static func normalizeHex(_ hex: String) -> String {
        var normalized = hex.uppercased()
            .replacingOccurrences(of: "#", with: "")
            .replacingOccurrences(of: " ", with: "")
        
        // Ensure 6 characters
        if normalized.count == 3 {
            // Convert short form (e.g., "FFF" to "FFFFFF")
            normalized = normalized.map { String(repeating: $0, count: 2) }.joined()
        }
        
        return "#" + normalized
    }
    
    /// Find closest named color
    private static func findClosestColor(to hex: String) -> (name: String, hex: String)? {
        guard let targetRGB = hexToRGB(hex) else { return nil }
        
        var closestColor: (name: String, hex: String)?
        var smallestDistance: Double = .infinity
        
        for (colorHex, colorName) in colorNames {
            guard let rgb = hexToRGB(colorHex) else { continue }
            
            let distance = colorDistance(rgb1: targetRGB, rgb2: rgb)
            if distance < smallestDistance {
                smallestDistance = distance
                closestColor = (colorName, colorHex)
            }
        }
        
        return closestColor
    }
    
    /// Get color distance between two hex colors
    private static func getColorDistance(hex1: String, hex2: String) -> Double? {
        guard let rgb1 = hexToRGB(hex1),
              let rgb2 = hexToRGB(hex2) else {
            return nil
        }
        return colorDistance(rgb1: rgb1, rgb2: rgb2)
    }
    
    /// Generate descriptive name based on RGB values
    private static func generateDescriptiveName(from hex: String) -> String {
        guard let rgb = hexToRGB(hex) else { return "Custom Color" }
        
        let r = rgb.r
        let g = rgb.g
        let b = rgb.b
        
        // Determine dominant color
        let max = Swift.max(r, g, b)
        let min = Swift.min(r, g, b)
        let range = max - min
        
        // Grayscale check
        if range < 20 {
            if max < 50 { return "Dark Gray" }
            else if max < 128 { return "Gray" }
            else if max < 200 { return "Light Gray" }
            else { return "White" }
        }
        
        // Determine hue
        var hue = ""
        if r >= g && r >= b {
            if g > b { hue = "Orange" }
            else { hue = "Red" }
        } else if g >= r && g >= b {
            if r > b { hue = "Yellow" }
            else if b > r { hue = "Cyan" }
            else { hue = "Green" }
        } else {
            if r > g { hue = "Magenta" }
            else { hue = "Blue" }
        }
        
        // Determine lightness
        let lightness = (max + min) / 2.0
        var prefix = ""
        if lightness < 85 { prefix = "Dark " }
        else if lightness > 170 { prefix = "Light " }
        
        return prefix + hue
    }
    
    /// Convert hex to RGB
    static func hexToRGB(_ hex: String) -> (r: Double, g: Double, b: Double)? {
        let hex = hex.replacingOccurrences(of: "#", with: "")
        guard hex.count == 6 else { return nil }
        
        var rgb: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&rgb)
        
        let r = Double((rgb >> 16) & 0xFF)
        let g = Double((rgb >> 8) & 0xFF)
        let b = Double(rgb & 0xFF)
        
        return (r, g, b)
    }
    
    /// Calculate color distance (Euclidean in RGB space)
    static func colorDistance(rgb1: (r: Double, g: Double, b: Double),
                             rgb2: (r: Double, g: Double, b: Double)) -> Double {
        let dr = rgb1.r - rgb2.r
        let dg = rgb1.g - rgb2.g
        let db = rgb1.b - rgb2.b
        
        return sqrt(dr*dr + dg*dg + db*db)
    }
    
    /// Parse multi-color RGB string (e.g., "#FF0000,#0000FF")
    static func parseMultiColorRGB(_ rgbString: String, colorNames: String?) -> [MaterialColor] {
        let hexColors = rgbString.split(separator: ",").map { $0.trimmingCharacters(in: .whitespaces) }
        let names = colorNames?.split(separator: "/").map { String($0.trimmingCharacters(in: .whitespaces)) } ?? []
        
        return hexColors.enumerated().map { index, hex in
            let colorName = index < names.count ? names[index] : generateColorName(from: hex)
            
            return MaterialColor(
                hex: hex,
                name: colorName,
                isPrimary: index == 0,
                autoGeneratedName: index >= names.count
            )
        }
    }
}
